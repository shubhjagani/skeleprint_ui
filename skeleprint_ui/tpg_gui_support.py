#! /usr/bin/env python
#
# Support module generated by PAGE version 4.8.9
# In conjunction with Tcl version 8.6
#    Feb 25, 2017 07:24:37 PM
#    Feb 25, 2017 11:35:57 PM


import sys
import math
import time
from pprint import pprint

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1


def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global axial_length
    axial_length = DoubleVar()

    global printbed_diameter
    printbed_diameter = DoubleVar()

    global final_diameter
    final_diameter = DoubleVar()

    global filament_width_og
    filament_width_og = DoubleVar()

    global helix_angle
    helix_angle = DoubleVar()

    global smear_factor
    smear_factor = DoubleVar() 

    global feedrate
    feedrate = DoubleVar() 

    axial_length.set(220.0)
    printbed_diameter.set(10.0)
    final_diameter.set(12.0)
    filament_width_og.set(1.0)
    helix_angle.set(45)
    smear_factor.set(100)
    feedrate.set(300)

def tpg(p1,p2,p3,p4,p5,p6):
    print('tpg_gui_support.tpg')
    sys.stdout.flush()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

commands = []

def axial_travel_calc(num_start_points, layer_diameter, filament_width):
    """This method takes a given number of layer start points, placed at angles of 2pi / start points

    It also takes the layer diameter (incremented every layer)
    It takes the filament (which is effectively stretched by the print angle)

    It returns the axial travel from one revolution to the next
    """

    # caution, this script uses angles in radians
    print_angle = math.asin(num_start_points*filament_width/layer_diameter)
    axial_travel = filament_width / math.cos(print_angle)
    return axial_travel

def angle_finder(num_start_points, circumference, filament_width):
    """This methods correct the helix angle to nearest value based on a specific number of start points
    """
    # caution, this script uses angles in radians

    theta = math.atan(num_start_points*filament_width/circumference)
    
    return theta

def init_gcode(feedrate):
    """This methods initializes the gcode and sets the feedrate (movement speed of the axis)
    """

    commands.append(";Start G Code")
    commands.append("G1 F{:.3f}".format(feedrate))
    #commands.append("G1 X{:.5f} Y{:.5f}").format(0, 0)

def main_gcode(current_layer, filament_width,x2, y, n, layer_height):
    """This methods prints the gcode for each layer
    """
    increment_size = 1/n    
    
    commands.append(";----------------------")
    commands.append("; layer {}".format(current_layer))
    commands.append(";----------------------")

    a = 0
    commands.append("G0 Z{:.5f}".format(current_layer * (layer_height)))
    if (current_layer %2  == 1):
        commands.append("G0 X{:.5f} Y{:.5f}".format(0, 0))
    else:
         commands.append("G0 X{:.5f} Y{:.5f}".format(x2, y))

    while (a/n < 1-increment_size and (current_layer-1) % 2 == 0):
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 X{:.5f} Y{:.5f}".format(x2, (y+(a/n))))
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format((y+(a/n))))
        commands.append("G1 X{:.5f} Y{:.5f}".format(0, (a/n)))
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format((a/n)))

    while (a/n < 1-increment_size and (current_layer-1) % 2 == 1):

        #print "start point", a
        #print "winding ratio", (a/n)
        
        commands.append("G1 X{:.5f} Y{:.5f}".format(0, ((a/n))))
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        
        commands.append("G1 Y{:.5f}".format(((a/n))))
        commands.append("G1 X{:.5f} Y{:.5f}".format(x2, y+(a/n)))

        a += 1
        
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format(y+(a/n)))

def end_gcode():
    commands.append(";----------------------")
    commands.append("G1 Z{:.5f}".format(30))
    commands.append("G1 X{:.5f} Y{:.5f}".format(0,0))
    commands.append("; End g code")
    print "\n".join(commands)
    timestr = time.strftime("%Y%m%d-%H%M%S")
    file = open(timestr+'_skeleprint_gcode.gcode' , 'w')
    file.write("\n".join(commands))

def tpg(axial_travel, filament_width_og, printbed_diameter, final_diameter, helix_angle, smear_factor):

    """
    Generates g-code for printing cylinders at various angles
    
    Required params: 
        axial direction travel - total length of print (ex. 200)
        filament width - width of filament (0.1) 
        print_radius - total radius of print (10)
        printbed diameter (10)
        helix angle - angle of the helix printed (0 - 90)
        smear factor - how much the subsequent layer is smeared (0 - 1)
    
    all units are in mm and degrees
    """
    feedrate = 300  #300 mm/min
    init_gcode(feedrate)

    smear_factor = smear_factor * 0.1

    layers = 0.5 * ((final_diameter - printbed_diameter)/(filament_width_og * smear_factor))
    if (layers < 1):
        layers = 1

    if (layers % 2 != 0 ):
        layers = math.floor(layers)
        print "The print diameter you've set is not symmetrical and has been rounded to {} layers".format(layers)

    print "layers:", layers

    print "original helix angle:", helix_angle 
    
    min_angle = math.atan(filament_width_og/(math.pi*printbed_diameter))
    print "min angle", min_angle

    if (helix_angle >= 90):
        helix_angle = 89.9999

    theta = helix_angle * math.pi/180 #convert degrees to radians
    #print "theta (rads):", theta 
    
    if (theta <= min_angle):  #print a single helix as close together as possible
        theta = min_angle


    current_layer = 1

    while (current_layer <= layers):
        
        print "Layer: ", current_layer
        layer_diameter = printbed_diameter + (current_layer * filament_width_og)
        circumference = math.pi * layer_diameter          
        print "circumference", circumference
        

        x_move_per_rev = (circumference)*(math.tan(theta))
        
        #distance traveled in the axial direction with every rotation


        print "x_move_per_rev:", x_move_per_rev  

        filament_width = filament_width_og/math.cos(theta) #filament width corrected for angle of deposition
        print "filament width update:", filament_width
        n = x_move_per_rev/filament_width        #number of start points


        if (float(n).is_integer()):
            print "number of total start points:", n
            print "updated angle", (theta*180/math.pi)

        else: 
            n = math.floor(n)
            theta = angle_finder(n, circumference, filament_width)
            print "theta (rads) for layer {}: {}".format(current_layer,theta)
            print "number of total start points for layer {}: {}".format(current_layer, n)
            print "updated helix angle", (theta*180/math.pi)

        #filament_width = filament_width_og/math.cos(theta) #corrects for change in filament width caused by print angle 

        x2 = axial_travel-filament_width        #adjusted for endpoint 
        y = axial_travel/x_move_per_rev         
        print "revs per winding:", y
        
        main_gcode(current_layer, filament_width, x2, y, n, filament_width_og * smear_factor)
        current_layer += 1
    
    end_gcode()



if __name__ == '__main__':
    import tpg_gui
    tpg_gui.vp_start_gui()





