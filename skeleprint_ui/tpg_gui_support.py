#! /usr/bin/env python
#
# Support module generated by PAGE version 4.8.9
# In conjunction with Tcl version 8.6
#    Feb 25, 2017 07:24:37 PM
#    Feb 25, 2017 11:35:57 PM

from __future__ import division
import sys, os
import math
import time
import datetime
from pprint import pprint



try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1


def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global axial_length
    axial_length = DoubleVar()

    global printbed_diameter
    printbed_diameter = DoubleVar()

    global final_diameter
    final_diameter = DoubleVar()

    global filament_width_og
    filament_width_og = DoubleVar()

    global helix_angle
    helix_angle = DoubleVar()

    global smear_factor
    smear_factor = DoubleVar() 

    global feedrate
    feedrate = DoubleVar() 

def tpg(p1,p2,p3,p4,p5,p6):
    print('tpg_gui_support.tpg')
    sys.stdout.flush()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

commands = []

def axial_travel_calc(num_start_points, layer_diameter, filament_width):
    """This method takes a given number of layer start points, placed at angles of 2pi / start points

    It also takes the layer diameter (incremented every layer)
    It takes the filament (which is effectively stretched by the print angle)

    It returns the axial travel from one revolution to the next
    """

    # caution, this script uses angles in radians
    print_angle = math.asin(num_start_points*filament_width/layer_diameter)
    axial_travel = filament_width / math.cos(print_angle)
    return axial_travel

def angle_finder(num_start_points, circumference, filament_width):
    """This methods correct the helix angle to nearest value based on a specific number of start points
    """
    # caution, this script uses angles in radians

    theta = math.atan(num_start_points*filament_width/circumference)
    
    return theta

def calc_tangential_velocity(feedrate, axial_travel, diameter, theta):
	
	hyp = (math.pi * diameter) / math.cos(theta)
	time = (hyp/feedrate) 
	w = (2 * math.pi)/time
	tangential_velocity = w * (diameter/2) 

	return tangential_velocity 

def init_layer(feedrate, current_layer, printbed_diameter, filament_width_og, layer_diameter):
    """This methods initializes the gcode and sets the feedrate (movement speed of the axis)
    """

    commands.append(";----------------------")
    commands.append("; layer {}".format(current_layer))
    commands.append(";----------------------")
    commands.append("G1 F{:.5f}".format(feedrate))

def main_gcode(current_layer, filament_width,x2, y, n, layer_height):
    """This methods prints the gcode for each layer
    """
    increment_size = 1/n    
    mm_per_rev = (10)   

    a = 0
    #print "current layer", current_layer
    #print "filament width", filament_width
    # print "increment", increment_size
    # print "n", n
    # print "y", y
    # print "layer height", layer_height
    commands.append("G0 Z{:.5f}".format(current_layer * (layer_height)))
    commands.append("G0 X{:.5f}".format(0))
    commands.append("G10 P0 L20 X0 Y0") #reset x and y axis position
       

    while (a/n < 1-increment_size and (current_layer) % 2 == 0):
        # print "in forward loop "
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(x2, mm_per_rev*(y+(a/n))))
        commands.append("M9")
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format(mm_per_rev*(y+(a/n))))
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(0, mm_per_rev*(a/n)))
        commands.append("M9")

        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format(mm_per_rev*(a/n)))
        

    while (a/n < 1-increment_size and (current_layer) % 2 == 1):
        # print "in forward loop "
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(x2, (-1) * mm_per_rev*(y+(a/n))))
        commands.append("M9")
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format((-1)*mm_per_rev*(y+(a/n))))
    
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(0, (-1)*mm_per_rev*(a/n)))
        commands.append("M9")
        a += 1
        #print "start point", a
        #print "winding ratio", (a/n)
        commands.append("G1 Y{:.5f}".format((-1)*mm_per_rev*(a/n)))


        # # print "in reverse loop "
        # #print "start point", a
        # #print "winding ratio", (a/n)
        # commands.append("M8 G1 X{:.5f} Y{:.5f}".format(0, (-1)*mm_per_rev*((a/n))))
        # #commands.append("M9")
        # a += 1
        # #print "start point", a
        # #print "winding ratio", (a/n)
        
        # commands.append("M8 G1 Y{:.5f}".format((-1)*mm_per_rev*(a/n)))
        # #commands.append("M9")
        # commands.append("M8 G1 X{:.5f} Y{:.5f}".format(x2, (-1)*mm_per_rev*(y+(a/n))))
        # #commands.append("M9")

        # a += 1
        
        # #print "start point", a
        # #print "winding ratio", (a/n)
        # commands.append("M8 G1 Y{:.5f}".format((-1)*mm_per_rev*(y+(a/n))))
        # #commands.append("M9")

def min_angle_print(current_layer,x2, y, layer_height ):
    """This methods prints for the min angle 
    """
    #increment_size = 1/n    
    mm_per_rev = (10)   

    a = 0
    #print "current layer", current_layer
    #print "filament width", filament_width
    # print "increment", increment_size
    # print "n", n
    # print "y", y
    # print "layer height", layer_height

    commands.append("G0 Z{:.5f}".format(current_layer * (layer_height)))
    commands.append("G0 X{:.5f}".format(0))
    commands.append("G10 P0 L20 X0 Y0") #reset x and y axis position

    if (current_layer %2  == 0):
        #commands.append("G0 X{:.5f} Y{:.5f}".format(0, mm_per_rev*0))
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(x2, mm_per_rev*y))
        commands.append("M9")

    else:
        #commands.append("G0 X{:.5f} Y{:.5f}".format(x2, mm_per_rev*y))
        commands.append("M8 G1 X{:.5f} Y{:.5f}".format(x2, (-1)*mm_per_rev*y))
        commands.append("M9")

  
def end_gcode():
    commands.append(";----------------------")
    commands.append("G0 Z{:.5f}".format(20))
    commands.append("G0 X{:.5f} Y{:.5f}".format(0,0))
    commands.append("; End g code")
    #print "\n".join(commands)
    
    timestr = time.strftime("%Y:%m:%d-%H_%M_%S")
    
    loc = os.path.join(os.path.expanduser("~"), "Desktop/gcode")
    filename = timestr+'_skeleprint.gcode'

    if not os.path.exists(loc):
        try:
            os.makedirs(loc)
        except OSError as exc: # Guard against race condition
            print "Directory not found, somehow you don't have a desktop. Or I can't find it. "
            if exc.errno != errno.EEXIST:
                raise
    
    with open(loc+"/"+filename, "w") as file:
        file.write("\n".join(commands))



def tpg(axial_travel, filament_width_og, printbed_diameter, final_diameter, helix_angle, smear_factor, feedrate_og):

    """
    Generates g-code for printing cylinders at various angles
    
    Required params: 
        axial direction travel - total length of print (ex. 200)
        filament width - width of filament (0.1) 
        print_radius - total radius of print (10)
        printbed diameter (10)
        helix angle - angle of the helix printed (0 - 90)
        smear factor - how much the subsequent layer is smeared (0 - 1)
    
    all units are in mm and degrees
    """
    

    del commands[:]     
    commands.append(";PARAMETERS")
    commands.append(";filament_width={}".format(filament_width_og))
    commands.append(";axial_travel={}".format(axial_travel))
    commands.append(";printbed_diameter={}".format(printbed_diameter))
    commands.append(";final_diameter={}".format(final_diameter))
    commands.append(";feedrate from flowrate={}".format(feedrate_og))


    smear_factor = smear_factor * 0.01
    print "smear factor", smear_factor
    
    layers = ((final_diameter - printbed_diameter)*0.5)/(filament_width_og * smear_factor)

    if (layers < 1):
    	layers = 1.0

    if (layers % (filament_width_og*smear_factor) != 0):
        layers = math.floor(layers)
        print "The print diameter you've set is not symmetrical and has been rounded to {} mm, with {} layers".format(final_diameter-filament_width_og ,layers)

    print "layers:", layers
    commands.append(";layers={}".format(layers))

    print "original helix angle:", helix_angle 
    
    min_angle = math.atan(filament_width_og/(math.pi*printbed_diameter))
    print "min angle", min_angle

    if (helix_angle >= 88): #any angle greater than this will print too slowly 
        helix_angle = 88
        max_angle_print = True

    theta = helix_angle * math.pi/180 #convert degrees to radians
    #print "theta (rads):", theta 
    base_case = False

    if (theta <= min_angle):  #print a single helix as close together as possible
        theta = min_angle
        base_case = True

    print "base case", base_case

    commands.append(";helix_angle={}".format((theta * 180)/math.pi))

    current_layer = 0
    commands.append("G0 G54 G17 G21 G90 G94 M5 M9 T0 F0.0 S0") #set defaults: absolute position, mm, stop all movements
    commands.append("G10 P0 L20 X0 Y0 Z0")

    while (current_layer < layers):
        
        print "Layer: ", current_layer
        layer_diameter = printbed_diameter + (current_layer * filament_width_og)
        print "layer diameter", layer_diameter 
        circumference = math.pi * layer_diameter          
        print "circumference", circumference
        

        x_move_per_rev = (circumference)*(math.tan(theta))
        
        #distance traveled in the axial direction with every rotation


        print "x_move_per_rev:", x_move_per_rev  

        filament_width = filament_width_og/math.cos(theta) #filament width corrected for angle of deposition
        print "filament width update:", filament_width
        n = x_move_per_rev/filament_width        #number of start points
        print "number of start points: ", n

        if (float(n).is_integer()):
            print "number of total start points:", n
            print "updated angle", (theta*180/math.pi)

        else: 
            if (n > 1):
            	n = math.floor(n)
            else:
            	n = 1
            theta = angle_finder(n, circumference, filament_width)
            print "theta (rads) for layer {}: {}".format(current_layer,theta)
            print "number of total start points for layer {}: {}".format(current_layer, n)
            print "updated helix angle", (theta*180/math.pi)

        #filament_width = filament_width_og/math.cos(theta) #corrects for change in filament width caused by print angle 

        x2 = axial_travel-filament_width        #adjusted for endpoint 
        y = axial_travel/x_move_per_rev         
        print "revs per winding:", y
        
        feedrate = calc_tangential_velocity(feedrate_og, axial_travel, layer_diameter, theta)
        init_layer(feedrate, current_layer, printbed_diameter, filament_width_og, layer_diameter)
        if (base_case):
        	min_angle_print(current_layer, x2, y, filament_width_og * smear_factor)
        else:
        	main_gcode(current_layer, filament_width, x2, y, n, filament_width_og * smear_factor)
        current_layer += 1
    
    end_gcode()


if __name__ == '__main__':
    import tpg_gui
    tpg_gui.vp_start_gui()





